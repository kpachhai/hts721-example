# SimpleHTS721: Owner‑governed HTS NFT with sensible defaults

This guide explains how `SimpleHTS721` works, what it does out of the box, and how to use it to deploy and operate an HTS‑backed ERC‑721 collection.

Sections:

- What SimpleHTS721 is
- What happens on deployment
- Keys, governance, and authorization
- Minting
- Management functions (pause/freeze/KYC/fees)
- Enumeration knobs
- HBAR handling
- When to consider pass‑through mode instead
- Quickstart usage

## What SimpleHTS721 is

`SimpleHTS721` is a minimal, ready‑to‑deploy collection contract that inherits from your `HTS721` base and adds `Ownable`. It is designed for a common setup:

- All HTS keys are assigned to the contract (CONTRACT_ID keys).
- A single owner governs minting and management actions.
- Safe defaults for Treasury, auto‑renew, and freeze behavior.
- Helper mint functions for convenience.

It keeps all the capabilities of `HTS721` (enumeration helpers, association helpers, management mixin) while enforcing a straightforward access policy: only the owner can tell the contract to exercise its HTS keys.

## What happens on deployment

When you deploy:

1. The constructor builds a `ManagementConfig` with sensible defaults:
   - Admin, KYC, Freeze, Wipe, Supply, Fee Schedule, Pause keys set to `CONTRACT_ID = address(this)`.
   - Treasury set to this contract (it receives new mints).
   - `freezeDefault = false`.
   - `autoRenewAccount = deployer`, `autoRenewPeriod` left 0 (base uses default).
2. The `HTS721` constructor calls the HTS precompile `createNonFungibleToken` and stores the new token address in `hederaTokenAddress`.
3. `Ownable` sets the initial owner to the deployer.

Result: you get an on‑chain governance point (this contract), and HTS will authorize privileged actions that originate from this contract address.

## Keys, governance, and authorization

Because keys are CONTRACT_ID = this contract:

- Hedera will accept management calls only when they originate from this contract.
- The contract enforces an app‑layer policy: `_requireManagementAuth()` is overridden to `require(msg.sender == owner())`. Only the owner can instruct the contract to act.
- This blocks “pure pass‑through” (EOA‑signature‑only) behavior by design; it’s deliberate for an owner‑operated collection.

You can always transfer ownership to a multisig or timelock later to decentralize control, or rotate keys with `updateTokenKeys` if you want different governance for specific capabilities.

## Minting

`SimpleHTS721` exposes:

- `mintTo(address to)` – owner‑only, mints a single NFT with a minimal 1‑byte metadata.
- `mintToWithMetadata(address to, bytes metadata)` – owner‑only, metadata up to 100 bytes.
- `mintBatch(address[] tos, bytes[] metadatas)` – owner‑only batch helper.

Under the hood:

- The token is minted to the Treasury (this contract) with `mintToken`.
- The contract updates `_maxObservedSerial` for enumeration bounds.
- It transfers the NFT to `to` via `transferFrom`.

Association reminder: The recipient must be associated (or have auto‑association available). For wallet‑triggered association, users can call the inherited:

- `associate(account)` – must be called by the account itself (`msg.sender == account` per HTS rules).

## Management functions (pause/freeze/KYC/fees)

As owner, you can call inherited functions that forward to HTS and check the response:

- `pause()` / `unpause()`
- `grantKyc(account)` / `revokeKyc(account)`
- `freeze(account)` / `unfreeze(account)`
- `wipe(account, serials)`
- `updateTokenKeys(keys)` (rotate Admin/KYC/Freeze/etc.)
- `updateNftRoyaltyFees(fixedFees, royaltyFees)` (post‑creation royalties; requires Fee Schedule key)

These are all subject to `_requireManagementAuth()` (owner‑only). The HTS precompile still validates the action per token rules (e.g., key present, token not deleted, etc.).

## Enumeration knobs

For index‑style enumeration:

- `totalSupply()` uses HTS `getTokenInfo`.
- `tokenByIndex` and `tokenOfOwnerByIndex` scan serials from 1..`_maxObservedSerial` and call `ownerOf`.
- Admin utilities:
  - `setEnumerationScanLimit(newLimit)` – default 10,000; increases or tightens the max scan bound (hard cap enforced).
  - `bumpMaxObservedSerial(newMax)` – update the known max serial if you suspect external/native mints occurred outside the contract flow.

For UIs, prefer:

- `tokensPaginated(offset, limit)`
- `tokensOfOwnerPaginated(owner, offset, limit)`

## HBAR handling

To avoid stuck HBAR:

- The contract accepts HBAR (`receive`/`fallback`) and logs `HBARReceived`.
- Owner can sweep via `withdrawHBAR(to, amount)` (guarded by management auth).

HBAR mistakenly sent to the HTS token address (`hederaTokenAddress`) is not recoverable by this contract.

## When to consider pass‑through mode instead

If you want compliance keys (KYC/Freeze) controlled by EOAs or a ThresholdKey (multisig) without app‑layer gating:

- Use an alternative derived contract that does not override `_requireManagementAuth()` for those operations (or adds a pass‑through toggle).
- Ensure the token’s KYC/Freeze keys are set to the intended EOAs/KeyList at creation or via `updateTokenKeys`.
- In that setup, anyone can call e.g., `grantKyc(account)`, but only transactions signed by the correct key(s) will succeed at the HTS precompile.

`SimpleHTS721` intentionally chooses owner‑governed CONTRACT_ID keys for simplicity and safety.

## Quickstart usage

1. Deploy

   - Deploy `SimpleHTS721("My Art", "ART", "My collection")`.
   - Record `hederaTokenAddress()`.

2. Set up (optional)

   - Transfer ownership to a multisig/timelock if needed.
   - Configure royalties via `updateNftRoyaltyFees(...)` (owner‑only).

3. Allow recipients to receive

   - Ask users to `associate(msg.sender)` from your contract (or ensure they have auto‑association).

4. Mint

   - Owner calls `mintTo(user)` or `mintToWithMetadata(user, data)`.

5. Manage

   - Pause/unpause: `pause()`, `unpause()`
   - KYC: `grantKyc(user)`, `revokeKyc(user)`
   - Freeze: `freeze(user)`, `unfreeze(user)`
   - Wipe (NFTs): `wipe(user, serials)`

6. Enumerate for UI

   - Use `tokensPaginated(offset, limit)` and `tokensOfOwnerPaginated(user, offset, limit)` for efficient views.
   - If you know external mints occurred, call `bumpMaxObservedSerial(newMax)`.

7. HBAR hygiene
   - Sweep accidental HBAR via `withdrawHBAR(treasury, amount)`.

With this, teams can quickly deploy an HTS‑backed ERC‑721 collection with sensible defaults and owner‑governed management, while preserving the option to migrate to more advanced governance later.
