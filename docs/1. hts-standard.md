# HTS721: Hedera Token Service–backed, ERC‑721–compatible base

This guide explains how HTS721 works, how it composes with HTSManagement to perform privileged token operations via the Hedera Token Service (HTS) precompile, how enumeration is implemented for HTS NFTs, how “pass‑through” with EOA keys works, and how the burnable extension fits in. It also includes simple examples for deploying your own HTS NFTs.

Sections:
- High-level architecture
- Contract creation and ManagementConfig
- Relationship to HTSManagement
- ERC‑721 compatibility (views, state changes, supportsInterface)
- Enumeration on HTS (totalSupply and index functions)
- Minting flow and association requirements
- HBAR handling (receive/fallback, withdraw)
- Pass‑through with EOA keys vs CONTRACT_ID keys
- Royalties and custom fees
- HTS721Burnable extension
- Examples


## High-level architecture

HTS721 is an abstract, ERC‑721–compatible facade for a native Hedera HTS Non‑Fungible Unique token. Instead of storing token balances and metadata inside the Solidity contract (like a standard ERC‑721 on EVM), HTS721 delegates ledger operations to the HTS precompile (address 0x167) and to the token’s own ERC‑721 facade (if and where exposed). This gives you:
- Native performance and fees of HTS for mint/transfers/management
- A familiar ERC‑721 surface for dapps, frontends, and marketplaces
- On‑chain programmable governance by assigning HTS keys to the contract


## Contract creation and ManagementConfig

Deploying HTS721 constructs a new HTS token via createNonFungibleToken and returns the resulting token address as `hederaTokenAddress` (immutable). Creation uses a `ManagementConfig` to set:
- Which HTS keys to configure (Admin, KYC, Freeze, Wipe, Supply, Fee Schedule, Pause)
- Who controls those keys: by default `CONTRACT_ID = address(this)` (the deployed contract)
- Treasury account (defaults to the contract)
- Default freeze status, and expiry/auto‑renew settings

Because keys can be set to CONTRACT_ID, all sensitive actions (pause, freeze, mint, wipe, etc.) can be made to flow through this contract’s logic, enabling on‑chain governance.


## Relationship to HTSManagement

HTSManagement is a reusable mixin that:
- Centralizes low-level calls to the HTS precompile (0x167) using `abi.encodeWithSelector`
- Wraps management actions like `grantKyc`, `revokeKyc`, `freeze`, `unfreeze`, `pause`, `unpause`, `wipe`, `updateTokenKeys`, and fee updates
- Exposes helpers to `associate` and `disassociate` user accounts with the token
- Defers authorization to an overridable hook `_requireManagementAuth()`

By default, `_requireManagementAuth()` is empty. Derived contracts should override it (e.g., with `Ownable` or roles) to enforce who is allowed to instruct the contract to use its HTS keys.

HTS721 inherits HTSManagement, so you automatically get these management functions tied to the specific `hederaTokenAddress` created in the constructor.


## ERC‑721 compatibility (views, state changes, supportsInterface)

HTS721 implements:
- Metadata views: `name()`, `symbol()`, `tokenURI(tokenId)` by delegating to the underlying token’s ERC‑721 metadata facade.
- Core views: `balanceOf(owner)`, `ownerOf(tokenId)`, approvals and operator checks.
- State‑changing methods: `approve`, `setApprovalForAll`, `transferFrom`, `safeTransferFrom` delegate to the HTS ERC‑721 facade. Note: `safeTransferFrom` does not call `onERC721Received` today since HTS does not (yet) invoke the receiver hook in the same manner; enable when supported.
- `supportsInterface`: advertises ERC‑165 for `IERC721`, `IERC721Metadata`, and `IERC721Enumerable` (see enumeration caveats below).

All low-level HTS precompile calls decode the response code and check for `SUCCESS = 22` where applicable (e.g., create/mint/totalSupply via `getTokenInfo`). For facade calls (the ERC‑721 interface on `hederaTokenAddress`), errors bubble up as standard Solidity reverts.


## Enumeration on HTS (totalSupply and index functions)

Because Hedera allows native mints/transfers outside the Solidity contract, a classic ERC‑721Enumerable index (maintained in hooks) is not reliable. HTS721 implements a best‑effort enumeration:

- `totalSupply()` calls HTS `getTokenInfo` and returns `tokenInfo.totalSupply`.
- `tokenByIndex(index)` and `tokenOfOwnerByIndex(owner, index)` scan serial numbers from 1 to `_maxObservedSerial`, calling `ownerOf(serial)` to check existence/ownership.
- `_maxObservedSerial` is updated on mints the contract performs, and can be bumped by admin later if external/native mints happen.
- To bound gas, scanning is only allowed up to `enumerationScanLimit` (default 10,000). Admin can adjust via `setEnumerationScanLimit(newLimit)`, up to a hard cap.
- Convenience helpers: `tokensPaginated(offset, limit)` and `tokensOfOwnerPaginated(owner, offset, limit)` offer safer pagination for UIs.

This approach works across HTS, but remember:
- Scans are O(N) in the scan range; use pagination and keep `_maxObservedSerial` realistic (bump it when you detect higher serials minted outside the contract).
- For large collections, prefer off‑chain indexing in production.


## Minting flow and association requirements

The `_mint` flow:
1) Calls HTS `mintToken` to mint one serial to the Treasury (by default, this contract).
2) Updates `_maxObservedSerial` with the minted serial if higher.
3) Transfers the serial from Treasury to the recipient via `transferFrom`.

Important: Recipients must be associated with the token (or have auto‑association capacity) or the transfer will fail. You can expose UX to call the inherited `associate(account)` from the user’s wallet (requires `msg.sender == account` per Hedera rules).


## HBAR handling (receive/fallback, withdraw)

Because users could accidentally send HBAR to the contract:
- `receive()` and `fallback()` are payable and emit `HBARReceived`.
- `withdrawHBAR(to, amount)` is restricted by your management auth and lets you sweep the balance safely to a designated address.

HBAR sent to the underlying HTS token address (`hederaTokenAddress`) is not recoverable by this contract; discourage users from sending HBAR there.


## Pass‑through with EOA keys vs CONTRACT_ID keys

HTS keys can be set to:
- `CONTRACT_ID`: the contract address. The HTS precompile authorizes privileged actions when the call originates from the authorized contract. Your contract decides who can tell it to act via `_requireManagementAuth()` (e.g., only owner, roles, timelock).
- EOA key(s) (ed25519/secp256k1), KeyList, ThresholdKey: the precompile authorizes based on the transaction’s signatures (“signature map”). In this mode, your contract can expose public “pass‑through” functions that simply forward to HTS and check the response code—only transactions signed by the correct key(s) will succeed.

Your base contracts already support both models:
- If you override `_requireManagementAuth()` (e.g., onlyOwner), you are choosing CONTRACT_ID governance. Only callers that pass your gate can exercise keys.
- If you leave `_requireManagementAuth()` empty, you allow pass‑through: anyone may call the function, but only txs with the right signatures (matching HTS key requirements) succeed at the precompile.
- Optional preflight checks: Hedera provides `isAuthorized`/`isAuthorizedRaw` precompiles to check signature sufficiency before calling HTS. They’re not required for correctness; use them only if you want to fail fast or build custom signer logic.

A hybrid approach is common: keep Supply key on the contract (programmable minting) and keep KYC/Freeze keys as EOAs (compliance) for pass‑through operations.


## Royalties and custom fees

Royalties on HTS are “custom fees”:
- Post‑creation: use `updateNonFungibleTokenCustomFees` via the management mixin (requires Fee Schedule key on the contract). This is flexible and can be governed on‑chain.
- At creation: alternatively, create with custom fees using `createNonFungibleTokenWithCustomFees` (not in this base constructor). Typically you’d do this in a factory then bind the facade.

Your current base focuses on post‑creation updates for flexibility.


## HTS721Burnable extension

`HTS721Burnable` is a thin extension that adds an internal `burn(tokenId)`:
- Requires caller is owner or approved.
- If the token is not held by Treasury (the contract), it requires approval to pull the token (`getApproved` or `isApprovedForAll`) and transfers it back to the contract.
- Calls HTS `burnToken` with the serial, which reduces total supply and permanently removes the NFT.

Expose a public or owner‑only method in your derived contract that calls the internal `burn` per your policy.


## Examples

### 1) Minimal managed collection (owner‑governed, CONTRACT_ID keys)

```solidity
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/access/Ownable.sol";
import "./HTS721.sol";
import "./HTS721Burnable.sol";

contract MyManaged721 is HTS721, HTS721Burnable, Ownable {
    constructor(string memory name_, string memory symbol_, string memory memo_)
        HTS721(name_, symbol_, memo_, _defaultConfig())
    {}

    // Owner‑only mint
    function mint(address to, bytes calldata metadata) external onlyOwner returns (uint256) {
        return _mint(to, metadata);
    }

    // Optional: Owner‑only burn (pulls back to treasury then burns)
    function burnOwned(uint256 tokenId) external onlyOwner {
        burn(tokenId);
    }

    // Governance: only owner can instruct management calls
    function _requireManagementAuth() internal view override {
        require(msg.sender == owner(), "not authorized");
    }

    function _defaultConfig() internal view returns (ManagementConfig memory cfg) {
        cfg.controller = address(this);
        cfg.admin = true; cfg.kyc = true; cfg.freeze = true; cfg.wipe = true;
        cfg.supply = true; cfg.feeSchedule = true; cfg.pause = true;
        cfg.treasury = address(this);
        cfg.freezeDefault = false;
        cfg.autoRenewAccount = msg.sender;
        cfg.autoRenewPeriod = int32(0); // use base default
    }
}
```

Usage outline:
- Deploy `MyManaged721(name, symbol, memo)`.
- Have users call `associate(msg.sender)` from the contract before receiving NFTs (unless auto‑association is available).
- Owner calls `mint(to, metadata)` to mint and deliver.
- Owner can call inherited management functions like `pause()`, `grantKyc(user)`, or `updateNftRoyaltyFees(...)`.
- If external/native mints occur (e.g., keys rotated), call `bumpMaxObservedSerial(newMax)` to keep enumeration practical.
- For large collections, tune `setEnumerationScanLimit(newLimit)` and use pagination helpers in UIs.

### 2) EOA pass‑through for KYC (compliance) with contract‑key Supply (hybrid)

```solidity
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.28;

import "./HTS721.sol";

contract Hybrid721 is HTS721 {
    constructor(string memory n, string memory s, string memory m, address treasury)
        HTS721(n, s, m, _cfg(treasury))
    {}

    // Leave _requireManagementAuth() empty to permit pass‑through for KYC/Freeze if those keys are EOAs.

    // But expose mint only to a controlled actor (e.g., sale manager)
    address public saleManager;
    modifier onlySaleManager() { require(msg.sender == saleManager, "not sale manager"); _; }
    function setSaleManager(address m) external /* governance */ { saleManager = m; }

    function publicMint(address to, bytes calldata metadata) external onlySaleManager returns (uint256) {
        return _mint(to, metadata);
    }

    function _cfg(address treasury) internal view returns (ManagementConfig memory cfg) {
        cfg.controller = address(this);
        cfg.admin = true; cfg.supply = true; cfg.feeSchedule = true; // keep Supply/fees on contract
        // Intentionally do NOT set KYC/Freeze keys to contract if you want EOA pass‑through
        cfg.kyc = false; cfg.freeze = false; cfg.wipe = false; cfg.pause = true;
        cfg.treasury = treasury == address(0) ? address(this) : treasury;
        cfg.freezeDefault = false;
        cfg.autoRenewAccount = msg.sender;
        cfg.autoRenewPeriod = int32(0);
    }
}
```

In this hybrid:
- Supply/Pause keys are on the contract (programmable minting/governance).
- KYC/Freeze keys remain EOAs (set at token creation via SDK or rotated later).
- Anyone may call `grantKyc(account)` on the contract, but the HTS precompile will only succeed if the transaction is signed by the EOA that holds the KYC key (pass‑through).
- Do not add app‑layer gates to those pass‑through functions if you want to preserve multisig/threshold pass‑through behavior.
