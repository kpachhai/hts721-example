# HTS721 Management Standards & Architecture

This document defines the opinionated “HTS721” pattern used in this repository for managing **Hedera Token Service (HTS) non‑fungible tokens (NFTs)** via lightweight smart contracts on the EVM. The design goal is to provide:

- Minimal bytecode (no redundant ERC‑721 passthrough)
- Modular, opt‑in feature extensions
- Explicit control of HTS keys (admin, supply, pause, freeze, wipe, kyc, fee)
- Clear lifecycle: create → operate → optionally decentralize (neutralize keys)

> IMPORTANT: These contracts do NOT proxy standard ERC‑721 calls (transferFrom / approve / setApprovalForAll / tokenURI) because users can interact **directly** with the underlying HTS mirror contract. The wrapper focuses exclusively on creation, supply, management and governance utilities.

---

## 1. Components Overview

| Layer | File | Responsibility | Deploy Alone? |
|-------|------|---------------|---------------|
| Core  | `HTS721Core.sol` | Create HTS NFT collection; hold keys; internal mint primitive | Yes |
| Errors | `HTS721Errors.sol` | Gas‑efficient custom errors | N/A |
| Common | `HTSCommon.sol` | Constants: precompile address, key bit flags | N/A |
| Interface | `IHTS721Core.sol` | Struct + init signature (InitConfig) | N/A |
| Interface | `IHTS721MintBurn.sol` | mint / burn / burnFrom surface | N/A |
| Interface | `IHTS721Manage.sol` | KYC / Freeze / Pause / Wipe / Fees / Delete | N/A |
| Extension | `HTS721MintBurn.sol` | Implements IHTS721MintBurn using supply key | No (needs Core) |
| Extension | `HTS721Management.sol` | Admin operations requiring respective keys | No (needs Core) |
| Extension | `HTS721KeyNeutralizerRandom.sol` | Irreversible rotation (“neutralization”) of keys | No (needs Core) |
| Extension | `HTS721Enumerable.sol` | Naive enumeration (serial scan) helpers | No (needs Core) |

### 1.1 Why No ERC‑721 Interface Inheritance
HTS already exposes an ERC‑721 mirror; duplicating the interface inside the wrapper:
- Increases bytecode past Spurious Dragon limits
- Adds pass‑through risk / complexity
- Requires state sync or forwarder patterns

We intentionally treat **the underlying HTS token as canonical** and the wrapper as a management lens.

---

## 2. Key Mask & InitConfig

Initialization uses one struct to avoid stack depth:

```solidity
IHTS721Core.InitConfig({
  name: "Collection",
  symbol: "CLT",
  memo: "demo",
  keyMask: uint8(KEY_ADMIN | KEY_SUPPLY | KEY_PAUSE),
  freezeDefault: false,
  autoRenewAccount: address(0),
  autoRenewPeriod: 0
});
```

### 2.1 Key Bit Flags

| Bit | Constant | Purpose | Typical Use |
|-----|----------|---------|-------------|
| 1   | `KEY_ADMIN`  | Rotate keys, delete token, update info | Always (governance) |
| 2   | `KEY_KYC`    | Grant / revoke KYC | Compliance flows |
| 4   | `KEY_FREEZE` | Freeze / unfreeze accounts | Risk mitigation |
| 8   | `KEY_WIPE`   | Wipe specific serials from accounts | Recovery / compliance |
| 16  | `KEY_SUPPLY` | Mint / burn NFTs | Always if minting |
| 32  | `KEY_FEE`    | Update custom (royalty / fixed) fees | Royalty markets |
| 64  | `KEY_PAUSE`  | Pause / unpause token transfers | Circuit breaker |

> NOTE: HTS NFT creation **requires** a supply key (bit 16). Leaving it out triggers RC=180 (TOKEN_HAS_NO_SUPPLY_KEY).

---

## 3. Core Contract (`HTS721Core`)

### 3.1 Responsibilities
- Single *initialize()* call (two‑phase deployment)
- Internal `_mintPrimitive()` returning serial ID
- Book‐keeping `_lastSerial` for enumeration / heuristics
- No direct user functions beyond initialization

### 3.2 Mint Flow (Extension)
`HTS721MintBurn.mintTo(to, metadata)`:
1. Calls `_mintPrimitive(metadata)`
2. HTS mints → treasury (wrapper) receives serial
3. Wrapper calls underlying ERC‑721 mirror `transferFrom(treasury, to, serial)`
4. Emits `MintForward(serial, to)`

### 3.3 Burn Flow
Two variants:
- `burn(serial)` – assumes treasury owns serial
- `burnFrom(owner, serial)` – pulls (needs underlying approval) then burns

### 3.4 Underlying Approvals
Because the owner of a user‑held serial is the user, the wrapper must be approved on the underlying ERC‑721 contract to “pull” before burning (or redistribute if you add custom logic).

---

## 4. Management (`HTS721Management`)

Provides owner‑only wrappers around HTS precompile methods that require token keys:

| Function | Key Required | HTS Selector |
|----------|--------------|--------------|
| `grantKyc` / `revokeKyc` | KYC | `grantTokenKyc` / `revokeTokenKyc` |
| `freeze` / `unfreeze` | FREEZE | `freezeToken` / `unfreezeToken` |
| `pause` / `unpause` | PAUSE | `pauseToken` / `unpauseToken` |
| `wipe(address,int64[])` | WIPE | `wipeTokenAccountNFT` |
| `updateNftRoyaltyFees(bytes,bytes)` | FEE | `updateNonFungibleTokenCustomFees` |
| `deleteToken()` | ADMIN (and other HTS preconditions) | `deleteToken` |

**Gas Minimization:** The contract decodes ABI‑encoded arrays off‑chain (user passes already encoded bytes) rather than exposing typed arrays in the method signature. This shrinks bytecode and keeps the surface generic.

---

## 5. Key Neutralization (`HTS721KeyNeutralizerRandom`)

Irreversibly **disables** selected keys by rotating each to a freshly derived Ed25519 public key for which no private key is known.

### 5.1 How It Works
1. Single PRNG seed retrieved from system contract (0.0.361 / `0x169`)
2. For each selected key: `derived = keccak256(rootSeed, keyType, slotIndex)`
3. Build new `TokenKey` with `ed25519 = derivedBytes` (32 bytes)
4. Call `updateTokenKeys`
5. Emit `KeysNeutralized(mask, rootSeed)`

Auditors can recompute per-key public keys deterministically using the event’s `rootSeed`.

### 5.2 Safety Switch
Neutralizing `ADMIN` requires `confirmAdmin=true` to avoid accidental loss of governance.

### 5.3 When to Neutralize
- After finishing distribution (neutralize SUPPLY)
- After fee schedule fixed (neutralize FEE)
- Final decentralization (neutralize ADMIN last)

---

## 6. Enumeration (`HTS721Enumerable`)

Naïve O(n) serial scan helper. Provided for **small collections** or off‑chain indexer bootstrap.

| Function | Behavior |
|----------|----------|
| `tokenByIndex(i)` | Scans up to `_lastSerial` counting existing owners |
| `tokensOfOwner(owner,maxScan)` | Collects into a dynamic array, trimmed in-place |
| `setEnumerationScanLimit(limit)` | Hard guard to avoid pathological loops |

> NOT FOR LARGE SUPPLIES – rely on external indexers for scale.

---

## 7. Custom Errors

Gas‑efficient, expressive reverts:

| Error | Condition |
|-------|-----------|
| `AlreadyInitialized()` | `initialize` called twice |
| `NotInitialized()` | Functions gated by `onlyInit` before init |
| `HtsCallFailed(sel, rc)` | Precompile returned non‑SUCCESS |
| `MetadataTooLarge()` | metadata > 100 bytes (HTS cap) |
| `TokenCreationFailed()` | createNonFungibleToken rc != SUCCESS |
| `CastOverflow()` | Downcast to `int64` overflow |
| `NotOwner()` | Owner-only guard |
| `EnumerationTooCostly()` | Scan limit exceeded |
| `IndexOutOfBounds()` | Enumeration index invalid |

---

## 8. Common Lifecycle Recipes

### 8.1 Standard Managed Collection (All Keys)
1. Deploy wrapper
2. `initialize( keyMask = 127 )`
3. Mint via `mintTo`
4. Manage (pause/unpause, freeze/unfreeze, grantKyc, update fees)
5. Neutralize keys in sequence: fee → freeze → wipe → pause → supply → admin

### 8.2 Fixed Supply Collection
1. Mint all serials
2. Neutralize SUPPLY key
3. (Optional) Neutralize ADMIN after fee & royalty finalization

### 8.3 Royalty Update
1. ABI‑encode `FixedFee[]` & `RoyaltyFee[]`
2. Call `updateNftRoyaltyFees(fixedEncoded, royaltyEncoded)`
3. Confirm on explorer (rc must be SUCCESS)
4. Eventually neutralize FEE key

### 8.4 Controlled Burn
1. Holder calls underlying `approve(wrapper, serial)` or `setApprovalForAll`
2. Owner calls `burnFrom(holder, serial)`
3. Serial moved to treasury then burned

---

## 9. Security & Governance

| Aspect | Recommendation |
|--------|---------------|
| Owner EOA | Use multisig / timelock for production |
| Neutralization | Irreversible—simulate in testnet first |
| Royalty Upgrades | Publish planned final fee schedule before neutralizing FEE key |
| Key Rotation (non-neutralizing) | Use conventional `updateTokenKeys` to point to new operational contract before switching off old one |
| Supply Freeze (Soft) | Neutralize SUPPLY key when done minting |

---

## 10. Extending the Framework

### 10.1 Creating a Custom Airdrop Module
- Inherit `HTS721Core` + `HTS721MintBurn`
- Add mapping `claimable[serial] = address`
- Mint to treasury (wrapper) & record intended owner
- Provide `claim(serial)` that transfers from treasury

### 10.2 Adding On-Chain Royalty Computation
HTS handles marketplace fee distribution natively; if you want *supplemental* logic (e.g., protocol fee) add a pre‑transfer hook pattern off-chain (indexer).

### 10.3 Off-Chain Indexer
- Use underlying token address for canonical ownership
- Subscribe to `Transfer` events emitted by underlying mirror (not wrapper)
- Optionally watch `MintForward` for initial distribution provenance

---

## 11. Error Code (RC) Quick Reference (Common)

| RC | Meaning (Simplified) | Cause | Action |
|----|----------------------|-------|--------|
| 22 | SUCCESS | OK | Continue |
| 180 | TOKEN_HAS_NO_SUPPLY_KEY | Missing supply key in create | Include bit 16 |
| 184 | TOKEN_NOT_ASSOCIATED_TO_ACCOUNT | KYC / transfer pre-association | Have user associate underlying |
| 194 | TOKEN_ALREADY_ASSOCIATED | Benign on re-association | Ignore |
| 206 | ACCOUNT_KYC_ALREADY_GRANTED (varies) | Redundant grantKyc | Handle idempotently off-chain |

(Exact numeric mapping may evolve; always consult latest Hedera response codes.)

---

## 12. Design Rationale Recap

| Decision | Rationale |
|----------|-----------|
| No ERC‑721 passthrough | Keep bytecode small, avoid double ownership logic |
| Single `InitConfig` struct | Prevent stack-too-deep & easier script usage |
| Random neutralization via PRNG | Auditable, deterministic derivations |
| ABI-encoded fee arrays | Reduce contract surface / code size |
| Separate minimal vs managed contracts | Let projects choose footprint level |

---

## 13. Example Initialize (TypeScript)

```ts
const ADMIN = 1, SUPPLY = 16, PAUSE = 64;
await wrapper.initialize({
  name: "Collection",
  symbol: "COLL",
  memo: "v1",
  keyMask: ADMIN | SUPPLY | PAUSE,
  freezeDefault: false,
  autoRenewAccount: ethers.ZeroAddress,
  autoRenewPeriod: 0
}, { value: ethers.parseEther("5") });
```

---

## 14. When Not To Use This Pattern

| Scenario | Alternative |
|----------|-------------|
| Need full ERC‑721 wrapper for wallets that only look at contract events | Use a “vault + virtual ledger” pattern (custodial) |
| Require on-chain royalty splitting beyond HTS | Custom payout contract referencing underlying |
| Massive enumeration needs | External indexer + Graph/SubQuery; avoid on-chain enumeration |

---

## 15. Checklist Before Mainnet

- [ ] Multisig owner set
- [ ] All target royalties applied & tested
- [ ] SUPPLY key neutralized post-final mint
- [ ] ADMIN neutralized (if aiming for immutability)
- [ ] Documentation published (init config + neutralization tx hashes)
- [ ] Off-chain monitoring for unexpected mints (should be zero after neutralization)

---

**End of Standard Specification**