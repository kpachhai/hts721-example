# Simple HTS Contracts Suite

This document explains the _simple_ example contracts that compose practical combinations of the HTS721 building blocks. They live at the repository root (`contracts/`) to make it obvious how to import and inherit them.

| Contract                   | Inherits                                                                                  | Included Features                                           | Target Use Case                             |
| -------------------------- | ----------------------------------------------------------------------------------------- | ----------------------------------------------------------- | ------------------------------------------- |
| `SimpleHTS721.sol`         | `HTS721Core`                                                                              | Initialization only                                         | Governance placeholder / reserved namespace |
| `SimpleHTS721MintBurn.sol` | `HTS721Core`, `HTS721MintBurn`, `HTS721Management`\*                                      | Mint + Burn (+ optional minimal management if key bits set) | Simple distributable collection             |
| `SimpleHTS721Managed.sol`  | `HTS721Core`, `HTS721MintBurn`, `HTS721Management`, `HTS721KeyNeutralizerRandom`          | Full management + neutralization                            | Lifecycle: launch → manage → decentralize   |
| `SimpleHTSEnumerable.sol`  | (alias of example) `HTS721Core`, `HTS721MintBurn`, `HTS721Management`, `HTS721Enumerable` | Adds naive enumeration helpers                              | Small supply with on-chain index queries    |

> \*`HTS721Management` methods only work for key bits actually granted in `keyMask` during initialization.

---

## 1. Contract Summaries

### 1.1 SimpleHTS721 (Core Only)

- Provides only `initialize(InitConfig)` and read access to `hederaTokenAddress`.
- No mint or management entrypoints.
- Suitable if you want a _future upgrade path_ (e.g., deploy core now, later deploy a management extension contract that becomes a delegate or rotates keys).

### 1.2 SimpleHTS721MintBurn

- Adds `mintTo`, `burn`, `burnFrom` from Mint/Burn extension.
- Includes Management base so you can still call (e.g.) `pause()` **if** you set `PAUSE` bit.
- KeyMask typical: `ADMIN | SUPPLY | PAUSE` (and maybe `FEE` if you plan royalties).

### 1.3 SimpleHTS721Managed

- Full production shape: mint/burn + management + neutralization.
- Supports key lifecycle: active operations → selective neutralization → final immutability (neutralize ADMIN).
- Exposes `neutralizeKeysRandom(Flags, confirmAdmin)`.

### 1.4 SimpleHTSEnumerable

- Adds naive serial scanning (`tokenByIndex`, `tokensOfOwner`) on top of Mint/Burn + Management.
- **Not scalable** for large supply; only for demos, small curated drops, or short-term indexing.

---

## 2. Deploy Scripts (Overview)

All deploy scripts follow this pattern:

```ts
const Factory = await ethers.getContractFactory("SimpleHTS721Managed");
const c = await Factory.deploy();
await c.waitForDeployment();

await c.initialize({
  name: "...",
  symbol: "...",
  memo: "...",
  keyMask: <bitwise OR keys>,
  freezeDefault: false,
  autoRenewAccount: deployer.address,
  autoRenewPeriod: 0
}, {
  value: ethers.parseEther("10"),
  gasLimit: 400_000
});
```

### 2.1 Required Keys

- **ALWAYS include `SUPPLY (16)`** for NFT creation (HTS enforces supply key presence).
- Minimal, mintless core still needs supply key; you can neutralize it immediately afterward if you want fixed supply = 0 pattern.

### 2.2 Funding

`value:` in initialize covers HTS token creation fees (adjust if network economics change).

---

## 3. Interaction Scripts (Key Actions)

### 3.1 Core

- Displays token address; demonstrates absence of mint methods.

### 3.2 MintBurn

- Mints serials to multiple signers.
- Shows failure of `burnFrom` without underlying approval.
- Executes `burnFrom` after approval.

### 3.3 Managed

- Grants KYC (if key present).
- Pauses and unpauses.
- Freezes/unfreezes.
- Neutralizes (rotates) `FREEZE` + `WIPE` keys.
- Executes burnFrom after user approval.
- Attempts deleteToken (requires all tokens cleared & contract holds ADMIN key at call time).

### 3.4 Enumerable

- Mints multiple tokens, enumerates them, transfers one via underlying then enumerates again.

---

## 4. Neutralization Flow Example (Managed)

```solidity
// Disable fee adjustments once final
neutralizeKeysRandom(
  Flags({ admin:false, kyc:false, freeze:false, wipe:false, supply:false, fee:true, pause:false }),
  false
);

// After final mint:
neutralizeKeysRandom(
  Flags({ admin:false, kyc:false, freeze:false, wipe:false, supply:true, fee:false, pause:false }),
  false
);

// Final immutability (no further control):
neutralizeKeysRandom(
  Flags({ admin:true, kyc:false, freeze:false, wipe:false, supply:false, fee:false, pause:false }),
  true
);
```

---

## 5. Royalty Fee Updates

1. Construct arrays in TypeScript:

```ts
const fixedFees = []; // IHederaTokenService.FixedFee[]
const royaltyFees = [
  // { numerator, denominator, fallbackFee, feeCollector, ... }
];
const fixedEncoded = ethers.AbiCoder.defaultAbiCoder().encode(
  ["tuple(uint256,uint256,address,bool,address)[]"],
  [fixedFees]
);
const royaltyEncoded = ethers.AbiCoder.defaultAbiCoder().encode(
  ["tuple(uint256,uint256,address,bool,address,uint256,uint256)[]"],
  [royaltyFees]
);
await managed.updateNftRoyaltyFees(fixedEncoded, royaltyEncoded);
```

2. Once satisfied, neutralize `FEE` key.

> Structure of these tuples depends on the precise Hedera solidity interface version; adjust accordingly if the upstream interface changes.

---

## 6. Burn vs BurnFrom

| Function                   | Precondition                         | Typical Use                               |
| -------------------------- | ------------------------------------ | ----------------------------------------- |
| `burn(serial)`             | Treasury already owns serial         | Batch mint + revoke model                 |
| `burnFrom(holder, serial)` | Wrapper approved on underlying token | User‑initiated disposal; redemption flows |

**Recommendation:** UIs should prompt for underlying `approve(wrapper, serial)` prior to `burnFrom`.

---

## 7. Enumeration Cautions

- `tokenByIndex(i)` increments a counter while scanning sequentially up to `_lastSerial`.
- If `_lastSerial` grows beyond a sensible threshold, revert early using `enumerationScanLimit`.
- For large collections use off‑chain indexers (Mirror Node / custom service).

---

## 8. Common Failure Modes

| Symptom                                     | Cause                                                           | Resolution                                         |
| ------------------------------------------- | --------------------------------------------------------------- | -------------------------------------------------- |
| rc=180 TOKEN_HAS_NO_SUPPLY_KEY              | Missing `SUPPLY` bit in keyMask                                 | Add bit 16                                         |
| rc=184 TOKEN_NOT_ASSOCIATED                 | User hasn’t associated underlying token (KYC / freeze scenario) | Ask user to call underlying associate()            |
| burnFrom revert                             | No underlying approval                                          | User calls `approve(wrapper, serial)`              |
| freeze/unfreeze revert after neutralization | FREEZE key rotated                                              | Document immutability; redeploy if needed          |
| deleteToken fails                           | Outstanding serials or disallowed state                         | Burn/wipe remaining NFTs, ensure ADMIN key present |

---

## 9. Integrating Into Your Own Contracts

### 9.1 Extend Only Core

```solidity
contract MyGovernedCollection is HTS721Core {
    constructor() HTS721Core() {}

    function initAsGov() external onlyOwner {
        initialize(IHTS721Core.InitConfig({
            name: "GovDrop",
            symbol: "GOV",
            memo: "phase1",
            keyMask: uint8(KEY_ADMIN | KEY_SUPPLY),
            freezeDefault: false,
            autoRenewAccount: address(this),
            autoRenewPeriod: 0
        }));
    }
}
```

### 9.2 Adding Custom Airdrop Logic

```solidity
contract Airdropper is HTS721Core, HTS721MintBurn {
    mapping(uint256 => bool) public locked;

    function mintAndLock(address to, bytes calldata data) external onlyOwner {
        uint256 s = mintTo(to, data);
        locked[s] = true;
    }

    // Further logic: require unlocking before user can transfer (enforced off‑chain or via custom checks using pre-transfer hooks if you wrap underlying).
}
```

---

## 10. Script Behavior Reference

| Script                  | Purpose                             | Key Actions                                    |
| ----------------------- | ----------------------------------- | ---------------------------------------------- |
| `deployCore.ts`         | Deploy + initialize minimal wrapper | keyMask includes SUPPLY (to satisfy creation)  |
| `deployMintBurn.ts`     | Deploy mint/burn variant            | Mints enabled                                  |
| `deployManaged.ts`      | Full management capabilities        | All keys set (127)                             |
| `deployEnumerable.ts`   | Adds enumeration facility           | For small collection demos                     |
| `interactCore.ts`       | Validate minimal surface            | No mint, mgmt calls fail                       |
| `interactMintBurn.ts`   | Mint and burn workflow              | Approval + burnFrom path                       |
| `interactManaged.ts`    | Governance ops                      | KYC, pause, freeze, neutralize, delete attempt |
| `interactEnumerable.ts` | Enumeration demonstration           | tokenByIndex / transfer / re-enumerate         |

---

## 11. Production Hardening Checklist

| Item                                                      | Status |
| --------------------------------------------------------- | ------ |
| Multi-sig owner configured                                | ☐      |
| All required mints complete                               | ☐      |
| SUPPLY key neutralized after final mint                   | ☐      |
| Fee schedule stable & FEE key neutralized                 | ☐      |
| Freeze/Wipe keys neutralized if not operationally needed  | ☐      |
| ADMIN key neutralized (post-governance freeze)            | ☐      |
| Public docs: initialization tx + neutralization tx hashes | ☐      |
| External monitor for unexpected supply increase           | ☐      |

---

## 12. Gas & Size Considerations

- Dropping ERC‑721 passthrough reduced core size dramatically.
- Using custom errors vs revert strings saves ~40–70 gas per failure.
- ABI‑encoded fee arrays reduce code size vs typed parameter overloads.
- Single PRNG call for multi-key neutralization avoids per-key randomness cost.

---

## 13. Future Extensions (Ideas)

| Idea                    | Description                                        |
| ----------------------- | -------------------------------------------------- |
| Claim / Vesting         | Mint to treasury + merkle/allowlist claim to users |
| Metadata Freeze Event   | Off-chain signal once metadata finalization done   |
| Multi-Phase Royalties   | Time or block segmented royalty schedule           |
| Cross-Chain Mirror Sync | Emit events bridging serial / metadata pointers    |

---

## 14. FAQ

**Q: Why must I include a supply key if I never mint?**  
A: HTS enforces presence of a supply key for NFT creation. Immediately neutralize it to enforce “permanently zero supply”.

**Q: Can I regain a neutralized key?**  
A: No. Neutralization rotates the key to an unknown random Ed25519 pubkey—irreversible by design.

**Q: How do I inspect which keys remain active?**  
A: Query token info via Mirror Node or decode last `updateTokenKeys` call logs; compare to recorded neutralization events.
